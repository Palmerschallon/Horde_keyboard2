<!doctype html>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
<title>Horde — pure canvas, dual-touch</title>
<style>
  :root { --bg:#0b0b0b; --fg:#e7e7e7; --stroke:#2a2a2a; --accent:#7aa8ff; }
  html,body { margin:0; height:100%; background:var(--bg); color:var(--fg);
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
  .wrap { display:grid; grid-template-rows:auto 1fr auto; height:100%; }
  header, footer { padding:8px 12px; border-bottom:1px solid var(--stroke); }
  footer { border-top:1px solid var(--stroke); border-bottom:none; display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
  .stack { position:relative; overflow:hidden; }
  canvas { position:absolute; inset:0; width:100%; height:100%; display:block; touch-action:none; }
  .chip { padding:4px 10px; border:1px solid #333; border-radius:999px; font-size:12px; cursor:pointer; user-select:none; }
  .chip.on { color:var(--accent); border-color:var(--accent); }
  #out { min-height:70px; flex:1; background:#0f0f0f; color:var(--fg); border:1px solid #242424; border-radius:6px; padding:10px; }
</style>

<div class="wrap">
  <header>horde — pure canvas • dual-touch • expand/collapse • v0.2</header>

  <div class="stack">
    <canvas id="void"></canvas>   <!-- swarm -->
    <canvas id="ui"></canvas>     <!-- halos, overlays -->
  </div>

  <footer>
    <span class="chip" id="mode">mode: collapse</span>
    <span class="chip" id="popMinus">pop −</span>
    <span class="chip" id="popPlus">pop +</span>
    <span class="chip" id="clear">clear</span>
    <textarea id="out" placeholder="(optional) notes / output…"></textarea>
  </footer>
</div>

<script>
/* ========================= CONFIG ========================= */
let MODE_EXPAND = 0;            // 0 = collapse (many→one), 1 = expand (one→many)
let POP = 6000;                 // starting population (adjustable)
const MAX_POP = 30000;

const ATTR_TOUCH_COLLAPSE = 0.22;   // collapse: attraction to touches
const ATTR_TOUCH_EXPAND_REP = 0.14; // expand: touch repels (bellows)
const NOISE = 0.10;
const DAMP = 0.86;
const MAXF = 0.8;
const MAXSPD = 1.8;

const ECHO_BURST = 300;         // expand: particles per burst
const ECHO_LIFE  = 240;         // frames

/* frontier (expand prefers unvisited zones) */
const FW = 64, FH = 40;

/* ====================== CANVAS SETUP ====================== */
const cv = document.getElementById('void');
const cu = document.getElementById('ui');
const dv = cv.getContext('2d');
const du = cu.getContext('2d');
const out = document.getElementById('out');
const dpr = Math.max(1, window.devicePixelRatio || 1);
let W=0,H=0;

function fit(){
  const parent = cv.parentElement;
  W = cv.clientWidth  = parent.clientWidth;
  H = cv.clientHeight = parent.clientHeight;
  for(const c of [cv, cu]){
    c.width = W*dpr; c.height = H*dpr;
    const ctx = c.getContext('2d');
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
}
window.addEventListener('resize', fit); fit();

/* ========================= STATE ========================== */
const agents = [];          // swarm
let visits = new Float32Array(FW*FH);   // frontier heat
const touches = new Map();  // id -> {x,y} active touches (multi-touch)

/* helpers */
function rnd(a=1){ return Math.random()*a; }
function clamp(v,a,b){ return v<a?a : v>b?b : v; }
function vibrate(p){ if(navigator.vibrate) navigator.vibrate(p); }

/* init swarm */
function resetSwarm(pop=POP){
  agents.length = 0;
  for(let i=0;i<pop;i++){
    agents.push({
      x: rnd(W), y: rnd(H),
      vx: (Math.random()*2-1)*0.5,
      vy: (Math.random()*2-1)*0.5,
      hue: 205 + rnd(40),
      echo:false, life:0
    });
  }
}
resetSwarm();

/* ===================== FRONTIER FIELD ===================== */
const cellW = ()=> W/FW, cellH = ()=> H/FH;

function markVisit(x,y){
  const cw=cellW(), ch=cellH();
  const gx = clamp((x/cw)|0, 0, FW-1);
  const gy = clamp((y/ch)|0, 0, FH-1);
  visits[gy*FW + gx] = Math.min(255, visits[gy*FW + gx] + 1);
}
function frontierForce(x,y){ // negative gradient (toward less visited)
  const cw=cellW(), ch=cellH();
  const gx = clamp((x/cw)|0, 1, FW-2);
  const gy = clamp((y/ch)|0, 1, FH-2);
  const idx=(X,Y)=> visits[Y*FW+X];
  const L=idx(gx-1,gy), R=idx(gx+1,gy), T=idx(gx,gy-1), B=idx(gx,gy+1);
  return { fx: (L-R)*0.002, fy: (T-B)*0.002 };
}
function coolVisits(){ for(let i=0;i<visits.length;i++) visits[i]*=0.995; }

/* ========================= TOUCH ========================== */
// Multi-touch: track all active touches (both thumbs)
function setTouch(id,x,y){ touches.set(id,{x,y}); }
function delTouch(id){ touches.delete(id); }
function firstTouch(){ // desktop fallback
  for(const v of touches.values()) return v;
  return null;
}
function drawHalos(){
  du.clearRect(0,0,W,H);
  for(const {x,y} of touches.values()){
    const rad = 80;
    const grd = du.createRadialGradient(x,y,4, x,y, rad);
    grd.addColorStop(0,"rgba(122,168,255,0.20)");
    grd.addColorStop(1,"rgba(122,168,255,0.0)");
    du.fillStyle = grd;
    du.beginPath(); du.arc(x,y,rad,0,6.283); du.fill();
    du.fillStyle="rgba(231,231,231,0.85)";
    du.beginPath(); du.arc(x,y,2,0,6.283); du.fill();
  }
}

/* Desktop mouse → single “touch” */
cv.addEventListener('mousedown', (e)=>{
  const r=cv.getBoundingClientRect(); setTouch('mouse', e.clientX-r.left, e.clientY-r.top); drawHalos();
});
window.addEventListener('mousemove', (e)=>{
  if(!touches.has('mouse')) return;
  const r=cv.getBoundingClientRect(); setTouch('mouse', e.clientX-r.left, e.clientY-r.top); drawHalos();
});
window.addEventListener('mouseup', ()=>{ delTouch('mouse'); drawHalos(); });

/* Mobile multi-touch */
cv.addEventListener('touchstart', (e)=>{
  e.preventDefault();
  const r=cv.getBoundingClientRect();
  for(const t of e.changedTouches) setTouch(t.identifier, t.clientX-r.left, t.clientY-r.top);
  drawHalos();
},{passive:false});
cv.addEventListener('touchmove', (e)=>{
  e.preventDefault();
  const r=cv.getBoundingClientRect();
  for(const t of e.changedTouches) setTouch(t.identifier, t.clientX-r.left, t.clientY-r.top);
  drawHalos();
},{passive:false});
cv.addEventListener('touchend', (e)=>{
  for(const t of e.changedTouches) delTouch(t.identifier);
  drawHalos();
});

/* simple “burst” on long press in EXPAND mode */
let pressTimer=null;
cv.addEventListener('touchstart', ()=>{
  if(!MODE_EXPAND) return;
  clearTimeout(pressTimer);
  pressTimer = setTimeout(()=>{
    const f = firstTouch(); if(!f) return;
    for(let i=0;i<ECHO_BURST;i++){
      agents.push({ x:f.x, y:f.y, vx:(Math.random()*2-1)*1.5, vy:(Math.random()*2-1)*1.5,
                    hue:205+rnd(30), echo:true, life:ECHO_LIFE });
    }
    vibrate([10,20,10]);
  }, 380);
},{passive:true});
cv.addEventListener('touchend', ()=> clearTimeout(pressTimer));

/* ========================= PHYSICS ======================== */
function step(){
  dv.clearRect(0,0,W,H);
  coolVisits();

  // draw + advance agents
  for(let i=0;i<agents.length;i++){
    const a = agents[i];
    let ax=0, ay=0;

    if (MODE_EXPAND && a.echo){
      // repel from each touch (bellows)
      for(const {x:tx,y:ty} of touches.values()){
        const dx = a.x - tx, dy = a.y - ty;
        const d = Math.hypot(dx,dy)+1e-3;
        const f = ATTR_TOUCH_EXPAND_REP * Math.min(1, 140/d);
        ax += f*dx; ay += f*dy;
      }
      // attract to frontier (less visited)
      const ff = frontierForce(a.x,a.y);
      ax += ff.fx * 0.10;
      ay += ff.fy * 0.10;

      // small noise
      ax += (Math.random()*2-1)*NOISE;
      ay += (Math.random()*2-1)*NOISE;

    } else {
      // COLLAPSE (or non-echo particles): attract to all touches
      for(const {x:tx,y:ty} of touches.values()){
        const dx = tx - a.x, dy = ty - a.y;
        const d = Math.hypot(dx,dy)+1e-3;
        const f = ATTR_TOUCH_COLLAPSE * Math.min(1, 140/d);
        ax += f*dx; ay += f*dy;
      }
      // wander
      ax += (Math.random()*2-1)*NOISE;
      ay += (Math.random()*2-1)*NOISE;
    }

    // normalize & damp
    const fmag = Math.hypot(ax,ay) || 1;
    const s = Math.min(1, MAXF/fmag);
    ax*=s; ay*=s;
    a.vx = clamp((a.vx + ax*0.08)*DAMP, -MAXSPD, MAXSPD);
    a.vy = clamp((a.vy + ay*0.08)*DAMP, -MAXSPD, MAXSPD);
    a.x += a.vx; a.y += a.vy;

    // wrap
    if(a.x<0) a.x+=W; if(a.x>W) a.x-=W;
    if(a.y<0) a.y+=H; if(a.y>H) a.y-=H;

    // mark usage for frontier
    markVisit(a.x, a.y);

    // echo lifetime
    if (a.echo && MODE_EXPAND){
      a.life -= 1; if(a.life<=0){ agents.splice(i--,1); continue; }
    }

    // draw
    const alpha = a.echo ? Math.max(0.12, a.life/ECHO_LIFE)*0.6 : 0.55;
    dv.fillStyle = `hsla(${a.hue},90%,70%,${alpha})`;
    dv.beginPath(); dv.arc(a.x,a.y, a.echo?0.9:1.1, 0, 6.283); dv.fill();
  }

  requestAnimationFrame(step);
}
requestAnimationFrame(step);

/* ========================= UI CHIPS ======================= */
const modeBtn = document.getElementById('mode');
modeBtn.onclick = ()=>{
  MODE_EXPAND = 1 - MODE_EXPAND;
  modeBtn.classList.toggle('on', MODE_EXPAND===1);
  modeBtn.textContent = 'mode: ' + (MODE_EXPAND ? 'expand' : 'collapse');
};

document.getElementById('clear').onclick = ()=>{
  out.value = '';
  // also clear visits so frontier resets
  visits = new Float32Array(FW*FH);
};

document.getElementById('popPlus').onclick = ()=>{
  const add = Math.min(2000, MAX_POP-POP);
  POP += add;
  for(let i=0;i<add;i++)
    agents.push({x:rnd(W),y:rnd(H),vx:(Math.random()*2-1)*0.5,vy:(Math.random()*2-1)*0.5,hue:205+rnd(40),echo:false,life:0});
};
document.getElementById('popMinus').onclick = ()=>{
  const cut = Math.min(2000, POP);
  POP -= cut;
  agents.splice(0, cut);
};
</script>
