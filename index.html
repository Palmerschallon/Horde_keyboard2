<!doctype html>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
<title>Horde Keyboard — swarm attractors</title>
<style>
  :root { --bg:#0b0b0b; --fg:#e7e7e7; --stroke:#2a2a2a; --accent:#7aa8ff; }
  html,body { margin:0; height:100%; background:var(--bg); color:var(--fg);
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
  .wrap { display:grid; grid-template-rows:auto 1fr auto; height:100%; }
  header, footer { padding:8px 12px; border-bottom:1px solid var(--stroke); }
  footer { border-top:1px solid var(--stroke); border-bottom:none; display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
  .stack { position:relative; overflow:hidden; }
  canvas { position:absolute; inset:0; width:100%; height:100%; display:block; touch-action:none; }
  .chip { padding:4px 10px; border:1px solid #333; border-radius:999px; font-size:12px; cursor:pointer; user-select:none; }
  .chip.on { color:var(--accent); border-color:var(--accent); }
  #out { min-height:86px; flex:1; background:#0f0f0f; color:var(--fg); border:1px solid #242424; border-radius:6px; padding:10px; }

  /* tuning HUD */
  .ctrl {
    position: fixed; right: 10px; bottom: 10px; background: #0a0a0acc;
    border:1px solid #222; border-radius:10px; padding:8px 10px; z-index:20; backdrop-filter: blur(4px);
  }
  .ctrl label { display:grid; grid-template-columns:auto 60px; gap:8px; align-items:center; font-size:12px; margin:4px 0; }
  .ctrl input[type="range"] { width: 140px; }
  .ctrl small { opacity:.7; }
</style>

<div class="wrap">
  <header>horde keyboard • long-press seed • slide to walk • swarm feels your touch</header>

  <div class="stack">
    <canvas id="grid"></canvas>    <!-- hex geometry + tokens -->
    <canvas id="swarm"></canvas>   <!-- void swarm: agents -->
    <canvas id="ui"></canvas>      <!-- hover halo + pulses -->
  </div>

  <footer>
    <span class="chip" id="swap">swap</span>
    <span class="chip" id="cal">recalibrate</span>
    <span class="chip" id="mode">swarm: solo</span>
    <span class="chip" id="clear">clear</span>
    <textarea id="out" placeholder="your sentence appears here…"></textarea>
  </footer>
</div>

<!-- tuning HUD -->
<div class="ctrl" id="ctrl">
  <label>attract <input id="kAttr" type="range" min="0" max="0.6" step="0.01"></label>
  <label>sug pull<input id="kSug"  type="range" min="0" max="0.6" step="0.01"></label>
  <label>noise   <input id="kNoise" type="range" min="0" max="0.5" step="0.005"></label>
  <label>max spd <input id="kSpd"  type="range" min="0.4" max="4" step="0.05"></label>
  <label>pop     <input id="kPop"  type="range" min="120" max="2000" step="40"></label>
  <small>two-finger: pan/zoom · one-finger: seed/slide · “swarm” toggles commit</small>
</div>

<script>
/* ========================= CONFIG ========================= */
const HEX_RINGS = 4;                 // radius -> rows 5..9..5
const HEX_SIZE  = 36;
const LONG_MS   = 380;
const SEED      = "•";

const IMPULSES = ["Explore","Question","Decide","Act","Exist","Again"];
const LEX = {
  Explore:["maybe","wander","open","beyond","try","else"],
  Question:["why","what","how","if","could","when"],
  Decide:["let's","choose","keep","stop","begin","return"],
  Act:["make","build","send","move","speak","write"],
  Exist:["i am","you are","this is","we are","it is","becomes"],
  Again:["then","again","still","back","once","more"]
};
const CONT = ["and","then",",",".","here","now"];

/* swarm (initial; live-tunable via sliders) */
let SWARM_COUNT = 24000;
let SWARM_ATTR_TOUCH = 0.22;   // attraction to hover
let SWARM_ATTR_SUG   = 0.18;   // attraction to active suggestion cells
let SWARM_NOISE      = 0.12;   // wander
let SWARM_MAXSPD     = 1.8;
const SWARM_COMMIT_RADIUS = 28;   // px around cell center
const SWARM_COMMIT_THRESHOLD = 14; // agents within radius to pulse
let SWARM_MODE = 0; // 0=solo (draw only), 1=chorus (may auto-commit)

/* ====================== CANVAS SETUP ====================== */
const cg = document.getElementById('grid').getContext('2d');
const cs = document.getElementById('swarm').getContext('2d');
const cu = document.getElementById('ui').getContext('2d');
const out = document.getElementById('out');
const dpr = Math.max(1, window.devicePixelRatio||1);
let W=0,H=0;

function fit() {
  const canvases=[cg.canvas,cs.canvas,cu.canvas];
  W = canvases[0].clientWidth  = canvases[0].parentElement.clientWidth;
  H = canvases[0].clientHeight = canvases[0].parentElement.clientHeight;
  for(const c of canvases){ c.width=W*dpr; c.height=H*dpr; c.getContext('2d').setTransform(dpr,0,0,dpr,0,0); }
}
window.addEventListener('resize', fit); fit();

/* ========================= CAMERA ========================= */
let cam = { x: 0, y: 0, z: 1 };
const ZMIN = 0.05, ZMAX = 50;
function centerCam(){ cam.x=W/2; cam.y=H/2; cam.z=1; } centerCam();
function toView(x,y){ return { x:(x-cam.x)/cam.z + W/2, y:(y-cam.y)/cam.z + H/2 }; }
function toWorld(x,y){ return { x:(x-W/2)*cam.z + cam.x, y:(y-H/2)*cam.z + cam.y }; }

/* ===================== HEX COORDINATES ==================== */
const SQRT3 = Math.sqrt(3);
function axialToPixel(q,r,cx,cy,hex=HEX_SIZE){
  return { x: cx + hex*(SQRT3*q + SQRT3/2*r), y: cy + hex*(3/2*r) };
}
function neighborsQR(q,r){ return [[1,0],[1,-1],[0,-1],[-1,0],[-1,1],[0,1]].map(([dq,dr])=>[q+dq,r+dr]); }
const k = (q,r)=>`${q},${r}`;

/* ======================= HIVE MODEL ======================= */
function buildHive(cx,cy,rings){
  const cells=new Map(); const arr=[];
  const c0={q:0,r:0, ...axialToPixel(0,0,cx,cy), token:SEED, kind:"seed", active:false};
  cells.set(k(0,0),c0); arr.push(c0);
  for(let n=1;n<=rings;n++){
    let q=n, r=0; const dirs=[[0,-1],[-1,0],[-1,1],[0,1],[1,0],[1,-1]];
    for(const [dq,dr] of dirs){ for(let i=0;i<n;i++){
      if(!cells.has(k(q,r))){ const p=axialToPixel(q,r,cx,cy); const c={q,r,x:p.x,y:p.y,token:"",kind:"",active:false}; cells.set(k(q,r),c); arr.push(c); }
      q+=dq; r+=dr;
    }}
  }
  // boundary outline
  const boundary=[]; let q=rings,r=0; const dirs=[[0,-1],[-1,0],[-1,1],[0,1],[1,0],[1,-1]];
  for(const [dq,dr] of dirs){ for(let i=0;i<rings;i++){ const p=axialToPixel(q,r,cx,cy); boundary.push(p); q+=dq; r+=dr; } }
  return {cells, arr, boundary, center:{cx,cy}, rings};
}

/* ===================== DUAL HIVE LAYOUT =================== */
let leftHigher=true;
function centers(){
  const vw=W, vh=H;
  return leftHigher
    ? { L:{cx: 0.33*vw, cy: 0.78*vh}, R:{cx: 0.67*vw, cy: 0.825*vh} }
    : { L:{cx: 0.33*vw, cy: 0.825*vh}, R:{cx: 0.67*vw, cy: 0.78*vh} };
}
let {L:CL,R:CR}=centers();
let HIVE_L=buildHive(CL.cx,CL.cy,HEX_RINGS);
let HIVE_R=buildHive(CR.cx,CR.cy,HEX_RINGS);
function rebuild(){ ({L:CL,R:CR}=centers()); HIVE_L=buildHive(CL.cx,CL.cy,HEX_RINGS); HIVE_R=buildHive(CR.cx,CR.cy,HEX_RINGS); drawAll(); }

/* ========================= RENDERING ====================== */
function hexPath(ctx,x,y,hex=HEX_SIZE){
  ctx.beginPath();
  for(let i=0;i<6;i++){ const a=Math.PI/6 + i*Math.PI/3;
    const px=x+hex*Math.cos(a), py=y+hex*Math.sin(a);
    (i?ctx.lineTo:ctx.moveTo).call(ctx,px,py);
  } ctx.closePath();
}
function drawHive(ctx,hive){
  ctx.save();
  // outline
  ctx.strokeStyle="#333"; ctx.lineWidth=1.2;
  ctx.beginPath(); hive.boundary.forEach((p,i)=> (i?ctx.lineTo:ctx.moveTo).call(ctx,p.x,p.y)); ctx.closePath(); ctx.stroke();
  // cells
  for(const c of hive.arr){
    const isActive = c.active || c.kind==="seed";
    ctx.fillStyle = isActive ? "rgba(122,168,255,0.08)" : "transparent";
    hexPath(ctx,c.x,c.y); ctx.fill();
    ctx.strokeStyle = isActive ? "#888" : "#333"; ctx.lineWidth = 1;
    ctx.stroke();
    if(c.token){
      ctx.fillStyle="#e7e7e7"; ctx.font="12px ui-monospace,Menlo,monospace";
      ctx.textAlign="center"; ctx.textBaseline="middle";
      ctx.fillText(c.token, c.x, c.y);
    }
  }
  ctx.restore();
}
function drawAll(){
  cg.setTransform(1,0,0,1,0,0);
  cg.clearRect(0,0,W,H);
  cg.save();
  cg.translate(W/2, H/2); cg.scale(1/cam.z, 1/cam.z); cg.translate(-cam.x, -cam.y);
  drawHive(cg,HIVE_L); drawHive(cg,HIVE_R);
  cg.restore();
}

/* ===================== INTERACTION STATE ================== */
let dragging=false, pressTimer=null, hiveCurr=null;
let seeded=null, current=null;
let hoverWorld=null;        // swarm forces use this
let hoverScreen=null;       // halo visual
const V = pat => navigator.vibrate && navigator.vibrate(pat);

function whichHive(x,y){ const dl=Math.hypot(x-CL.cx,y-CL.cy), dr=Math.hypot(x-CR.cx,y-CR.cy); return dl<dr ? HIVE_L : HIVE_R; }
function pick(hive,x,y){ let best=null,dmin=1e9; for(const c of hive.arr){ const d=Math.hypot(x-c.x,y-c.y); if(d<HEX_SIZE*0.9 && d<dmin){best=c; dmin=d;} } return best; }
function neighborsOf(h,c){ return neighborsQR(c.q,c.r).map(([q,r])=> h.cells.get(`${q},${r}`)).filter(Boolean); }
function resetActive(h){ h.arr.forEach(c=>c.active=false); }

function bloom(h,cell){
  resetActive(h);
  const nbs = neighborsOf(h,cell);
  nbs.forEach((n,i)=>{
    n.active=true;
    if(cell.kind==="seed"){ n.kind="impulse"; n.token=IMPULSES[i%IMPULSES.length]; }
    else if(cell.kind==="impulse"){ n.kind="word"; n.token=(LEX[cell.token]||[])[i%6]||""; }
    else { n.kind="word"; n.token=CONT[i%CONT.length]; }
  });
  drawAll();
}

function append(tok){
  if(!tok) return;
  const punct=[",",".",";","?","!"]; let s=out.value;
  if(punct.includes(tok)) s=s.replace(/\s*$/,"")+tok+" ";
  else if(s===""||/\s$/.test(s)) s+=tok+" ";
  else s+=" "+tok+" ";
  out.value=s; out.selectionStart=out.selectionEnd=s.length;
}

/* Hover / halo (screen-space) */
function drawHover(x,y){
  cu.clearRect(0,0,W,H);
  if(!x && !y) return;
  cu.save();
  const rad = HEX_SIZE*2.4;
  const grd = cu.createRadialGradient(x,y,4, x,y, rad);
  grd.addColorStop(0, "rgba(122,168,255,0.22)");
  grd.addColorStop(1, "rgba(122,168,255,0.0)");
  cu.fillStyle = grd;
  cu.beginPath(); cu.arc(x,y,rad,0,6.283); cu.fill();
  cu.fillStyle="rgba(231,231,231,0.75)";
  cu.beginPath(); cu.arc(x,y,1.5,0,6.283); cu.fill();
  cu.restore();
}

/* ========================= SWARM ========================== */
const agents = [];
function initSwarm(){
  agents.length=0;
  for(let i=0;i<SWARM_COUNT;i++){
    agents.push({
      x: Math.random()*W, y: Math.random()*H,
      vx: (Math.random()*2-1)*0.5, vy:(Math.random()*2-1)*0.5,
      hue: 200 + Math.random()*40
    });
  }
}
initSwarm();

/* nearest active suggestion cells */
function activeCells(){
  const list=[];
  for(const c of HIVE_L.arr) if(c.active && c.token) list.push(c);
  for(const c of HIVE_R.arr) if(c.active && c.token) list.push(c);
  return list;
}

/* post-processing target */
const swOff = document.createElement('canvas'); const swCtx = swOff.getContext('2d');
function syncSwOff(){ swOff.width=W; swOff.height=H; } syncSwOff(); window.addEventListener('resize', syncSwOff);
let USE_SW_POST = true;

function applySwarmPost(){
  if(!USE_SW_POST) return;
  swCtx.setTransform(1,0,0,1,0,0);
  swCtx.clearRect(0,0,W,H);
  swCtx.drawImage(cs.canvas,0,0);

  // monochrome + contrast curve
  const img = swCtx.getImageData(0,0,W,H); const d=img.data;
  for(let i=0;i<d.length;i+=4){
    const r=d[i], g=d[i+1], b=d[i+2];
    let y = 0.2126*r + 0.7152*g + 0.0722*b;
    y = Math.pow(y/255, 0.9) * 255;
    d[i]=d[i+1]=d[i+2]=y;
  }
  swCtx.putImageData(img,0,0);

  // glow
  swCtx.globalCompositeOperation='lighter';
  swCtx.filter='blur(2px)'; swCtx.drawImage(swOff,0,0);
  swCtx.filter='blur(5px)'; swCtx.drawImage(swOff,0,0);
  swCtx.filter='none'; swCtx.globalCompositeOperation='source-over';

  // grain
  const gimg = swCtx.getImageData(0,0,W,H); const gd=gimg.data;
  const npx=(W*H*0.08)|0;
  for(let k=0;k<npx;k++){
    const p=((Math.random()*W)|0 + ((Math.random()*H)|0)*W)<<2;
    const n=(Math.random()*34-17)|0;
    gd[p]=gd[p+1]=gd[p+2]=Math.max(0,Math.min(255,gd[p]+n));
  }
  swCtx.putImageData(gimg,0,0);

  // present to visible canvas
  cs.setTransform(1,0,0,1,0,0);
  cs.clearRect(0,0,W,H);
  cs.drawImage(swOff,0,0);
}

function stepSwarm(){
  cs.setTransform(1,0,0,1,0,0);
  cs.clearRect(0,0,W,H);

  // draw in world space
  cs.save();
  cs.translate(W/2, H/2); cs.scale(1/cam.z, 1/cam.z); cs.translate(-cam.x, -cam.y);

  const actives = activeCells();
  const crowd = new Map(); // cell -> count
  const nowHover = hoverWorld;

  for(const a of agents){
    let ax=0, ay=0;

    // attraction to hover field (your touch)
    if(nowHover){
      const dx = nowHover.x - a.x, dy = nowHover.y - a.y;
      const d = Math.hypot(dx,dy)+1e-3;
      const f = SWARM_ATTR_TOUCH * Math.min(1, 140/d);
      ax += f * dx; ay += f * dy;
    }

    // attraction to active suggestion cells
    for(const c of actives){
      const dx = c.x - a.x, dy = c.y - a.y;
      const d = Math.hypot(dx,dy)+1e-3;
      const f = SWARM_ATTR_SUG * Math.min(1, 120/d);
      ax += f * dx; ay += f * dy;

      if(d < SWARM_COMMIT_RADIUS){
        crowd.set(c, (crowd.get(c)||0)+1);
      }
    }

    // noise / wander
    ax += (Math.random()*2-1) * SWARM_NOISE;
    ay += (Math.random()*2-1) * SWARM_NOISE;

    // integrate
    a.vx = Math.max(-SWARM_MAXSPD, Math.min(SWARM_MAXSPD, a.vx + ax*0.05));
    a.vy = Math.max(-SWARM_MAXSPD, Math.min(SWARM_MAXSPD, a.vy + ay*0.05));
    a.x += a.vx; a.y += a.vy;

    // wrap
    if(a.x<0) a.x+=W; if(a.x>W) a.x-=W;
    if(a.y<0) a.y+=H; if(a.y>H) a.y-=H;

    // draw
    cs.fillStyle=`hsla(${a.hue},90%,70%,0.55)`;
    cs.beginPath(); cs.arc(a.x,a.y,1.1,0,6.283); cs.fill();
  }

  // pulses + chorus
  for(const [cell,count] of crowd.entries()){
    if(count >= SWARM_COMMIT_THRESHOLD){
      pulseCell(cell);
      if(SWARM_MODE===1){ append(cell.token); V(10); bloom(whichHive(cell.x,cell.y), cell); }
    }
  }

  cs.restore();
  applySwarmPost();
  requestAnimationFrame(stepSwarm);
}
requestAnimationFrame(stepSwarm);

function pulseCell(c){
  cu.save();
  const v = toView(c.x,c.y);
  cu.strokeStyle="rgba(122,168,255,0.45)";
  cu.lineWidth=3;
  // pulse outline in screen space for readability
  cu.beginPath();
  for(let i=0;i<6;i++){
    const a=Math.PI/6 + i*Math.PI/3;
    const px=v.x+HEX_SIZE*Math.cos(a), py=v.y+HEX_SIZE*Math.sin(a);
    (i?cu.lineTo:cu.moveTo).call(cu,px,py);
  }
  cu.closePath(); cu.stroke();
  cu.restore();
}

/* ==================== CONTROLS / START ==================== */
document.getElementById('swap').onclick=()=>{ leftHigher=!leftHigher; rebuild(); };
document.getElementById('clear').onclick=()=>{ out.value=""; };
document.getElementById('cal').onclick=async()=>{
  alert("Calibration: tap once where your LEFT thumb naturally rests, then tap where your RIGHT thumb rests.");
  const pickTap=()=>new Promise(res=>{
    const handler=e=>{ const r=cg.canvas.getBoundingClientRect(); const t=e.touches?e.touches[0]:e;
      const x=t.clientX-r.left, y=t.clientY-r.top; window.removeEventListener('mousedown',handler);
      window.removeEventListener('touchstart',handler); res(toWorld(x,y)); };
    window.addEventListener('mousedown',handler,{once:true});
    window.addEventListener('touchstart',handler,{once:true,passive:false});
  });
  const L=await pickTap(); const R=await pickTap();
  CL={cx:L.x, cy:L.y}; CR={cx:R.x, cy:R.y};
  HIVE_L=buildHive(CL.cx,CL.cy,HEX_RINGS); HIVE_R=buildHive(CR.cx,CR.cy,HEX_RINGS); drawAll();
};
const modeBtn=document.getElementById('mode');
modeBtn.onclick=()=>{ SWARM_MODE = (SWARM_MODE+1)%2; modeBtn.classList.toggle('on', SWARM_MODE===1); modeBtn.textContent = 'swarm: ' + (SWARM_MODE? 'chorus':'solo'); };

function drawAllAndStart(){ drawAll(); initSwarm(); }
drawAllAndStart();

/* ============== INPUT / GESTURES (camera + seeds) ========= */
function ptScreen(ev){
  const r=cg.canvas.getBoundingClientRect();
  const e=ev.touches?ev.touches[0]:ev;
  return {x:e.clientX-r.left, y:e.clientY-r.top};
}
function ptWorld(ev){ const s=ptScreen(ev); return toWorld(s.x,s.y); }

function down(ev){
  ev.preventDefault();
  const s = ptScreen(ev); const w = ptWorld(ev);
  hoverScreen=s; hoverWorld=w; drawHover(s.x,s.y);
  hiveCurr = whichHive(w.x,w.y);
  const hit = pick(hiveCurr,w.x,w.y); if(!hit) return;
  pressTimer = setTimeout(()=>{ seeded=current=hit; bloom(hiveCurr,hit); V([8,18,8]); dragging=true; }, LONG_MS);
}
function move(ev){
  const s = ptScreen(ev); const w = ptWorld(ev);
  hoverScreen=s; hoverWorld=w; drawHover(s.x,s.y);
  if(!dragging) return;
  ev.preventDefault();
  const hit = pick(hiveCurr,w.x,w.y);
  if(hit && hit!==current && hit.active){ append(hit.token); current=hit; bloom(hiveCurr,hit); V(12); }
}
function up(){ clearTimeout(pressTimer); pressTimer=null; dragging=false; }

/* Touch gestures: two-finger pan/zoom camera */
let pinch=null; // {id1,id2,startDist,startZ,anchorWorld,lastMid}

cg.canvas.addEventListener('touchstart', (e)=>{
  e.preventDefault();
  if (e.touches.length===2){ clearTimeout(pressTimer); dragging=false; }
  if (e.touches.length===1) down(e);

  if (e.touches.length===2){
    const r=cg.canvas.getBoundingClientRect();
    const a={x:e.touches[0].clientX-r.left, y:e.touches[0].clientY-r.top};
    const b={x:e.touches[1].clientX-r.left, y:e.touches[1].clientY-r.top};
    const mid={x:(a.x+b.x)/2, y:(a.y+b.y)/2};
    pinch = {
      id1:e.touches[0].identifier, id2:e.touches[1].identifier,
      startDist: Math.hypot(a.x-b.x, a.y-b.y),
      startZ: cam.z,
      anchorWorld: toWorld(mid.x, mid.y),
      lastMid: mid
    };
  }
},{passive:false});

window.addEventListener('touchmove', (e)=>{
  if (pinch){
    e.preventDefault();
    const r=cg.canvas.getBoundingClientRect();
    let A=null,B=null;
    for (const t of e.touches){
      if (t.identifier===pinch.id1) A={x:t.clientX-r.left,y:t.clientY-r.top};
      if (t.identifier===pinch.id2) B={x:t.clientX-r.left,y:t.clientY-r.top};
    }
    if (A && B){
      const mid={x:(A.x+B.x)/2, y:(A.y+B.y)/2};
      const d=Math.hypot(A.x-B.x, A.y-B.y);
      cam.z = Math.max(ZMIN, Math.min(ZMAX, pinch.startZ * (pinch.startDist / d)));
      const before = pinch.anchorWorld;
      const after  = toWorld(mid.x, mid.y);
      cam.x += before.x - after.x;
      cam.y += before.y - after.y;
      cam.x -= (mid.x - pinch.lastMid.x) * cam.z;
      cam.y -= (mid.y - pinch.lastMid.y) * cam.z;
      pinch.lastMid = mid;
      drawAll();
    }
    return;
  }
  move(e);
},{passive:false});

window.addEventListener('touchend', (e)=>{
  if (pinch){
    let still=false;
    for (const t of e.touches) if (t.identifier===pinch.id1 || t.identifier===pinch.id2) still=true;
    if (!still) pinch=null;
  }
  up();
});

/* Mouse (desktop) */
cg.canvas.addEventListener('mousedown', down);
window.addEventListener('mousemove', move);
window.addEventListener('mouseup', up);

/* ============== TUNING HUD WIRING ========================= */
(function(){
  const $=id=>document.getElementById(id);
  $('kAttr').value = SWARM_ATTR_TOUCH;
  $('kSug').value  = SWARM_ATTR_SUG;
  $('kNoise').value= SWARM_NOISE;
  $('kSpd').value  = SWARM_MAXSPD;
  $('kPop').value  = SWARM_COUNT;

  $('kAttr').oninput = e => window.SWARM_ATTR_TOUCH = parseFloat(e.target.value);
  $('kSug').oninput  = e => window.SWARM_ATTR_SUG   = parseFloat(e.target.value);
  $('kNoise').oninput= e => window.SWARM_NOISE      = parseFloat(e.target.value);
  $('kSpd').oninput  = e => window.SWARM_MAXSPD     = parseFloat(e.target.value);

  $('kPop').oninput  = e => {
    const target = parseInt(e.target.value,10);
    if (target > agents.length){
      const add = target - agents.length;
      for(let i=0;i<add;i++)
        agents.push({ x:Math.random()*W, y:Math.random()*H, vx:(Math.random()*2-1)*0.5, vy:(Math.random()*2-1)*0.5, hue:200+Math.random()*40 });
    } else if (target < agents.length){
      agents.splice(0, agents.length - target);
    }
    SWARM_COUNT = target;
  };
})();
</script>
